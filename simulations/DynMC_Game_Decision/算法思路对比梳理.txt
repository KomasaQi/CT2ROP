算法思路1：场景并行深度优先搜索，全部深度优先计算并行 + 上次决策计算深度结果（并行）                                                                  全部5s    精简1.7s    预计C++实现：0.7s （估计快2.5倍以上）
算法思路2：阶段并行广度优先搜索，每阶段全部展开+上次决策结果深度（并行）
算法思路3：阶段并行广度优先局部搜索，每阶段展开目前为止代价最低的n个场景+上次计算深度结果（并行）
算法思路4：阶段并行广度优先启发式搜索，每阶段展开目前为止代价+启发函数代价结果低的n个场景+上次计算深度结果（并行）
算法思路5：场景并行广度优先搜索，少单多双，每个场景只考虑预设的n种可能+上次计算深度结果（并行）
算法思路6：场景并行广度优先局部搜索，分场景并行，少单多双，每个场景都依次展开，只展开n个目前代价最低的场景+上次计算深度结果（并行）
算法思路7：场景并行广度优先启发式搜索，分场景并行，少单多双，每个场景都依次展开，只展开n个目前代价+启发函数代价最低的场景+上次计算深度结果（并行）
算法思路8：深度广度综合剪枝搜索，分别并行所有场景中给定好的一个（集合A）（+上次计算结果深度），记录最低的，再阶段并行广度优先局部搜索（之前未进行的），强迫每个分支不能超过m个

缩写：情况少的可以单核多个场景，情况多的可以分两个核心并行→少单多双

评价指标和启发函数应该做的是同样的事情，评价内容应该相同才能相加
评价指标：行车间距（安全）、通行平均延误时间（高效）、与参考车速（经济车速）的相差（经济）、加速度累计与加加速度累计（平稳）、与期望车道的偏差（规则）
启发函数：

启发式剪枝规则：
①若到节点g为止的J >J*则，g以下被剪枝
②若节点g的行车距离<安全距离阈值smin，则g以下被剪枝


自车意图


想法记录：比我快的前车和比我慢的后车是完全不用多次仿真的，因为我的决策对这些车没有影响。
分场景进行优化，

算法思路2：
初始化：先初始化一个场景，加入本阶段的scenarioSet（一个cell）中
循环中：
	根据scenarioSet中的元素个数*3预分配一个足够大的空的cell
	每个阶段，先是主核心进行操作遍历scenarioSet中每一个场景
		检查该场景是否可以进行分支，如果可以进行分支，就场景计数器+1，复制这个场景到cell中并修改其决策内容
		提前生成一个有效场景大小的cell，准备接收即将被放回的内容
	并行：根据有效场景个数进行进行仿真放回cell中
		根据有效场景个数构建新的
			
后处理：



周车预测概率模型验证算法流程
①找到所有不换道的车辆ID，用其训练一个驾驶员模型，输入为前车速度、自车速度、相对车间距，输出是自车下一时刻（自己选的较大的一个时间间隔，比如0.5s）的加速度。→驾驶员模型得到啦
②找出所有换道的车的ID（筛选一下，保证在最开始时没有在换道，而是在行驶比如1s之后才开始换道），只考虑第一次换道用其进行验证，大概5000条数据左右，找到上述车辆存在的帧范围，截取中间的部分构建数据集
③对所有上述车辆的轨迹，根据规则找到换道中间、开始、结束的时间点，本条记录一直持续到车辆消失在视野范围。
④在每一帧，先读取下一帧的加速度作为自己不换道的周车加速度设想；在每一帧，根据自车车道判断，是否可以向左/右换道，并利用驾驶员模型预测换道之后的新的后车的加速度，得到MOBIL模型的中间输出：三个决策的加速度值（+被影响的周车的）。
⑤将MOBIL中间输出输入给我的概率换道模型，输出向左右中换道的本时刻概率→*仿真步长，与前一时刻的三向决策概率相加更新，得到新的累计概率值。（前后时刻相乘？还是相加？）
⑥（因为筛选的数据都是换道的，所以仿真结束前一定发生过换道）当车辆发生换道开始时，如果该向换道概率>阈值delta，并且发生在概率累计最快的地方附近2s左右，则认为是成功的案例。

→☆从硕哥模型验证的论文入手，找MOBIL和其他换道模型验证的论文看其思路
